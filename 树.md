## 树
### 树的遍历
使用栈模拟的二叉树深度优先遍历的过程，下面实现了二叉树的前序遍历，改变stack的压栈顺序即可实现中序遍历、后序遍历，以及N叉树的前序遍历、后序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
    if (!root) {
        return []
    }
    const ret = []
    const stack = [new Command('GO', root)]
    while (stack.length) {
        const curCommand = stack.pop()
        if (curCommand.action === 'ADD') {
            ret.push(curCommand.node.val)
        } else {
            if (curCommand.node.right != null) {
                stack.push(new Command('GO', curCommand.node.right));
            }
            if (curCommand.node.left != null) {
                stack.push(new Command('GO', curCommand.node.left));
            }
            stack.push(new Command('ADD', curCommand.node));
        }
    }

    return ret
};

function Command(action, node) {
    this.action = action;
    this.node = node
}
```

#### 相关题目
[二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal)

[二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal)

[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

[N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal)

[N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal)

### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree)
给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 3
```

#### 示例 2：
```
输入：root = [1,null,2]
输出: 2
```

#### 示例 3：
```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

#### 提示
- $树中节点的数量在 [0, 10^4] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root){
        return 0
    }
    const left = maxDepth(root.left)
    const right = maxDepth(root.right)

    return Math.max(left, right) + 1
};
```

### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree)
给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：** 叶子节点是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 2
```

#### 示例 2：
```
输入：root = [2,null,3,null,4,null,5,null,6]
输出: 5
```

#### 提示
- $树中节点的数量在 [0, 10^5] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root){
        return 0
    }
    const left = minDepth(root.left)
    const right = minDepth(root.right)

    if(!root.left){
        return right + 1
    }

    if(!root.right){
        return left + 1
    }

    return Math.min(left, right) + 1
};
```

### [路径总和](https://leetcode.cn/problems/path-sum)
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。**叶子节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg "Magic Gardens")
```
输入: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出: true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg "Magic Gardens")
```
输入：root = [1,2,3], targetSum = 5
输出: false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

#### 示例 3：
```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

#### 提示
- 树中节点的数目在范围 [0, 5000] 内
- -1000 <= Node.val <= 1000
- -1000 <= targetSum <= 1000

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root){
        return false
    }
    const diffVal = targetSum - root.val
    if(!root.left && !root.right){
        return diffVal === 0
    }

    return hasPathSum(root.left, diffVal) || hasPathSum(root.right, diffVal)
};
```

### [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree)
给你二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg "Magic Gardens")
```
输入: root = [4,2,7,1,3,6,9]
输出: [4,7,2,9,6,3,1]
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg "Magic Gardens")
```
输入：root = [2,1,3]
输出: [2,3,1]
解释：树中存在两条根节点到叶子节点的路径：
```

#### 示例 3：
```
输入：root = []
输出：[]
```

#### 提示
- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root){
        return root
    }
    const left = invertTree(root.right)
    const right = invertTree(root.left)

    return new TreeNode(root.val, left, right)
};
```

### [相同的树](https://leetcode.cn/problems/same-tree/)
给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg "Magic Gardens")
```
输入: p = [1,2,3], q = [1,2,3]
输出: true
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 提示
- 两棵树上的节点数目都在范围 `[0, 100]` 内
- $-10^4 <= Node.val <= 10^4$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {
    if (!p && !q) {
        return true
    }

    if(p && q && p.val === q.val){
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }

    return false
};
```

### [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

#### 示例 1：
![这是图片](https://pic.leetcode.cn/1698026966-JDYPDU-image.png "Magic Gardens")
```
输入: root = [1,2,2,3,4,4,3]
输出: true
```

#### 示例 2：
![这是图片](https://pic.leetcode.cn/1698027008-nPFLbM-image.png "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

#### 提示
- 树中节点数目在范围 `[1, 1000]` 内
- -100 <= Node.val <= 100

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if(!root){
        return true
    }

    return isSymmetricCore(root.left, root.right)
};

function isSymmetricCore(node1, node2) {
    if (!node1 && !node2) {
        return true
    }

    if (node1 && node2 && node1.val === node2.val) {
        return isSymmetricCore(node1.left, node2.right) && isSymmetricCore(node1.right, node2.left)
    }

    return false
}
```

### [求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
计算从根节点到叶节点生成的 **所有数字之和** 。**叶节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg "Magic Gardens")
```
输入: root = [1,2,3]
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg "Magic Gardens")
```
输入：root = [4,9,0,5,1]
输出: 1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

#### 提示
- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    let res = 0;
    const dfs = (node, sum) => {
        if(!node){
            return
        }
        sum = sum * 10 + node.val
        if(!node.left && !node.right){
            res += sum

            return 
        }
        dfs(node.left, sum)
        dfs(node.right, sum)
    }
    dfs(root, 0)

    return res
};
```

### [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大 **（一个节点也可以是它自己的祖先）** 。”

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 树中节点数目在范围 $[2, 10^5]$ 内。
- $-10^9 <= Node.val <= 10^9$
- 所有 `Node.val` 互不相同。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(!root){
        return root
    }
    if(root === p || root === q){
        return root
    }
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if(left && right){
        return root
    }

    return left ? left : right
};
```

### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg "Magic Gardens")
```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

#### 示例 2：
```
输入：preorder = [-1], inorder = [-1]
输出: [-1]
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- preorder 和 inorder 均 无重复 元素
- inorder 均出现在 preorder
- preorder 保证 为二叉树的前序遍历序列
- inorder 保证 为二叉树的中序遍历序列

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length || !inorder.length){
        return null
    }
    const rootVal = preorder.shift()
    const index = inorder.findIndex(number => number === rootVal)
    const leftPreorder = preorder.slice(0, index)
    const rightPreorder = preorder.slice(index)
    const leftInorder = inorder.slice(0, index)
    const rightInorder = inorder.slice(index + 1)
    const left = buildTree(leftPreorder, leftInorder)
    const right = buildTree(rightPreorder, rightInorder)

    return new TreeNode(rootVal, left, right)
};
```

#### 相关题目
[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### [前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)
给定一个整数数组，它表示BST(即 **二叉搜索树** )的 **先序遍历** ，构造树并返回其根。**保证** 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。**二叉搜索树** 是一棵二叉树，其中每个节点，`Node.left` 的任何后代的值 **严格小于** `Node.val` , `Node.right` 的任何后代的值 **严格大于** `Node.val`。二叉树的 **前序遍历** 首先显示节点的值，然后遍历`Node.left`，最后遍历`Node.right`。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2019/03/06/1266.png "Magic Gardens")
```
输入: preorder = [8,5,1,7,10,12]
输出: [8,5,10,1,7,null,12]
```

#### 示例 2：
```
输入：preorder = [1,3]
输出: [1,null,3]
```

#### 提示
- 1 <= preorder.length <= 100
- 1 <= preorder[i] <= 10^8
- preorder 中的值 **互不相同**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function (preorder) {
    const tree = new Tree()
    preorder.forEach(num => tree.insert(num))

    return tree.root
};

function Tree() {
    this.root = null;

    this.insert = function (val) {
        const newNode = new TreeNode(val)

        if (!this.root) {
            this.root = newNode
        } else {
            insertNode(this.root, newNode);
        }
    }

    function insertNode(node, newNode) {
        if (newNode.val < node.val) {
            if (!node.left) {
                node.left = newNode
            } else {
                insertNode(node.left, newNode)
            }
        } else {
            if (!node.right) {
                node.right = newNode
            } else {
                insertNode(node.right, newNode)
            }
        }
    }
}
```

### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
给你一棵二叉树的根节点，返回该树的 **直径** 。二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。两节点之间路径的 **长度** 由它们之间边数表示。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg "Magic Gardens")
```
输入: root = [1,2,3,4,5]
输出: 3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

#### 示例 2：
```
输入：root = [1,2]
输出：1
```

#### 提示
- 树中节点数目在范围 $[1, 10^4]$ 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    let res = 0;
    const getDepth = node => {
        if(!node){
            return 0
        }

        const leftDepth = getDepth(node.left)
        const rightDepth = getDepth(node.right)

        res = Math.max(res, (leftDepth + rightDepth))

        return Math.max(leftDepth, rightDepth) + 1
    }

    getDepth(root)

    return res
};
```
