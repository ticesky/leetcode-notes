## 目录

- [树的遍历](#树的遍历)
  - [相关题目](#相关题目)
- [建树问题](#建树问题)
  - [最大二叉树](#最大二叉树)
  - [最大二叉树 II](#最大二叉树-ii)
  - [从前序与中序遍历序列构造二叉树](#从前序与中序遍历序列构造二叉树)
    - [类似题目](#类似题目)
  - [前序遍历构造二叉搜索树](#前序遍历构造二叉搜索树)
- [结构判断问题](#结构判断问题)
  - [相同的树](#相同的树)
  - [对称二叉树](#对称二叉树)
  - [另一棵树的子树](#另一棵树的子树)
  - [二叉树中的链表](#二叉树中的链表)
- [自底向上整合子树结果](#自底向上整合子树结果)
  - [二叉树的最大深度](#二叉树的最大深度)
  - [二叉树的最小深度](#二叉树的最小深度)
  - [翻转二叉树](#翻转二叉树)
  - [路径总和](#路径总和)
  - [二叉树的直径](#二叉树的直径)
  - [二叉树中的最大路径和](#二叉树中的最大路径和)
  - [在二叉树中分配硬币](#在二叉树中分配硬币)
  - [出现次数最多的子树元素和](#出现次数最多的子树元素和)
  - [二叉树的坡度](#二叉树的坡度)
  - [删除给定值的叶子节点](#删除给定值的叶子节点)
  - [寻找重复的子树](#寻找重复的子树)
  - [二叉树中的最长交错路径](#二叉树中的最长交错路径)
- [层序遍历及变种](#层序遍历及变种)
  - [二叉树的层序遍历 II](#二叉树的层序遍历-ii)
  - [二叉树的锯齿形层序遍历](#二叉树的锯齿形层序遍历)
  - [二叉树的层平均值](#二叉树的层平均值)
  - [二叉树的堂兄弟节点](#二叉树的堂兄弟节点)
  - [二叉树的垂序遍历](#二叉树的垂序遍历)
- [DFS或BFS均可解决的问题](#DFS或BFS均可解决的问题)
  - [找树左下角的值](#找树左下角的值)
  - [在每个树行中找最大值](#在每个树行中找最大值)
  - [在二叉树中增加一行](#在二叉树中增加一行)
- [只能用DFS解决的问题](#只能用DFS解决的问题)
  - [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
  - [二叉树最长连续序列](#二叉树最长连续序列)
  - [最长同值路径](#最长同值路径)
  - [二叉树的右视图](#二叉树的右视图)
- [需要两次搜索才能解决的问题](#需要两次搜索才能解决的问题)
  - [输出二叉树](#输出二叉树)
  - [分裂二叉树的最大乘积](#分裂二叉树的最大乘积)
  - [二叉树中所有距离为 K 的结点](#二叉树中所有距离为-k-的结点)
- [最近公共祖先问题](#最近公共祖先问题)
  - [二叉树的最近公共祖先](#二叉树的最近公共祖先)
  - [具有所有最深节点的最小子树](#具有所有最深节点的最小子树)

## 树的遍历
使用栈模拟的二叉树深度优先遍历的过程，下面实现了二叉树的前序遍历，改变stack的压栈顺序即可实现中序遍历、后序遍历，以及N叉树的前序遍历、后序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
    if (!root) {
        return []
    }
    const ret = []
    const stack = [new Command('GO', root)]
    while (stack.length) {
        const curCommand = stack.pop()
        if (curCommand.action === 'ADD') {
            ret.push(curCommand.node.val)
        } else {
            if (curCommand.node.right != null) {
                stack.push(new Command('GO', curCommand.node.right));
            }
            if (curCommand.node.left != null) {
                stack.push(new Command('GO', curCommand.node.left));
            }
            stack.push(new Command('ADD', curCommand.node));
        }
    }

    return ret
};

function Command(action, node) {
    this.action = action;
    this.node = node
}
```

### 相关题目
[二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal)

[二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal)

[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

[N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal)

[N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal)

## 建树问题
### [最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)
给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` 构建的 ***最大二叉树*** 。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg "Magic Gardens")
```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg "Magic Gardens")
```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

#### 提示
- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000
- nums 中的所有整数 **互不相同**

```js
```

### [最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/)
**最大树** 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。给你最大树的根节点 `root` 和一个整数 `val` 。就像 [之前的问题](#最大二叉树) 那样，给定的树是利用 `Construct(a)` 例程从列表 `a`（`root = Construct(a)`）递归地构建的：
- 如果 a 为空，返回 null 。
- 否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。
- root 的左子树将被构建为 Construct([a[0], a[1], ..., a[i - 1]]) 。
- root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]) 。
- 返回 root 。

请注意，题目没有直接给出 `a` ，只是给出一个根节点 `root = Construct(a)` 。假设 `b` 是 `a` 的副本，并在末尾附加值 `val`。题目数据保证 `b` 中的值互不相同。返回 `Construct(b)` 。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png "Magic Gardens")
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png "Magic Gardens")
```
输入：root = [4,1,3,null,null,2], val = 5
输出：[5,4,null,1,3,null,null,2]
解释：a = [1,4,2,3], b = [1,4,2,3,5]
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png "Magic Gardens")
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png "Magic Gardens")
```
输入：root = [5,2,4,null,1], val = 3
输出：[5,2,4,null,1,null,3]
解释：a = [2,1,5,4], b = [2,1,5,4,3]
```

#### 示例 3：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png "Magic Gardens")
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png "Magic Gardens")
```
输入：root = [5,2,3,null,1], val = 4
输出：[5,2,4,null,1,3]
解释：a = [2,1,5,3], b = [2,1,5,3,4]
```

#### 提示
- 树中节点数目在范围 [1, 100] 内
- 1 <= Node.val <= 100
- 树中的所有值 **互不相同**
- 1 <= val <= 100

```js
```

### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg "Magic Gardens")
```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

#### 示例 2：
```
输入：preorder = [-1], inorder = [-1]
输出: [-1]
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- preorder 和 inorder 均 无重复 元素
- inorder 均出现在 preorder
- preorder 保证 为二叉树的前序遍历序列
- inorder 保证 为二叉树的中序遍历序列

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length || !inorder.length){
        return null
    }
    const rootVal = preorder.shift()
    const index = inorder.findIndex(number => number === rootVal)
    const leftPreorder = preorder.slice(0, index)
    const rightPreorder = preorder.slice(index)
    const leftInorder = inorder.slice(0, index)
    const rightInorder = inorder.slice(index + 1)
    const left = buildTree(leftPreorder, leftInorder)
    const right = buildTree(rightPreorder, rightInorder)

    return new TreeNode(rootVal, left, right)
};
```

#### 类似题目
[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### [前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)
给定一个整数数组，它表示BST(即 **二叉搜索树** )的 **先序遍历** ，构造树并返回其根。**保证** 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。**二叉搜索树** 是一棵二叉树，其中每个节点，`Node.left` 的任何后代的值 **严格小于** `Node.val` , `Node.right` 的任何后代的值 **严格大于** `Node.val`。二叉树的 **前序遍历** 首先显示节点的值，然后遍历`Node.left`，最后遍历`Node.right`。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2019/03/06/1266.png "Magic Gardens")
```
输入: preorder = [8,5,1,7,10,12]
输出: [8,5,10,1,7,null,12]
```

#### 示例 2：
```
输入：preorder = [1,3]
输出: [1,null,3]
```

#### 提示
- 1 <= preorder.length <= 100
- 1 <= preorder[i] <= 10^8
- preorder 中的值 **互不相同**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function (preorder) {
    const tree = new Tree()
    preorder.forEach(num => tree.insert(num))

    return tree.root
};

function Tree() {
    this.root = null;

    this.insert = function (val) {
        const newNode = new TreeNode(val)

        if (!this.root) {
            this.root = newNode
        } else {
            insertNode(this.root, newNode);
        }
    }

    function insertNode(node, newNode) {
        if (newNode.val < node.val) {
            if (!node.left) {
                node.left = newNode
            } else {
                insertNode(node.left, newNode)
            }
        } else {
            if (!node.right) {
                node.right = newNode
            } else {
                insertNode(node.right, newNode)
            }
        }
    }
}
```

## 结构判断问题
### [相同的树](https://leetcode.cn/problems/same-tree/)
给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg "Magic Gardens")
```
输入: p = [1,2,3], q = [1,2,3]
输出: true
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 提示
- 两棵树上的节点数目都在范围 `[0, 100]` 内
- $-10^4 <= Node.val <= 10^4$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {
    if (!p && !q) {
        return true
    }

    if(p && q && p.val === q.val){
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }

    return false
};
```

### [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
给你一个二叉树的根节点 `root` ，检查它是否轴对称。

#### 示例 1：
![这是图片](https://pic.leetcode.cn/1698026966-JDYPDU-image.png "Magic Gardens")
```
输入: root = [1,2,2,3,4,4,3]
输出: true
```

#### 示例 2：
![这是图片](https://pic.leetcode.cn/1698027008-nPFLbM-image.png "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

#### 提示
- 树中节点数目在范围 `[1, 1000]` 内
- -100 <= Node.val <= 100

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if(!root){
        return true
    }

    return isSymmetricCore(root.left, root.right)
};

function isSymmetricCore(node1, node2) {
    if (!node1 && !node2) {
        return true
    }

    if (node1 && node2 && node1.val === node2.val) {
        return isSymmetricCore(node1.left, node2.right) && isSymmetricCore(node1.right, node2.left)
    }

    return false
}
```

### [另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg "Magic Gardens")
```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg "Magic Gardens")
```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```

#### 提示
- root 树上的节点数量范围是 [1, 2000]
- subRoot 树上的节点数量范围是 [1, 1000]
- $-10^4 <= root.val <= 10^4$
- $-10^4 <= subRoot.val <= 10^4$

```js
```

### [二叉树中的链表](https://leetcode.cn/problems/linked-list-in-binary-tree/)
给你一棵以 `root` 为根的二叉树和一个 `head` 为第一个节点的链表。如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 `head` 为首的链表中每个节点的值，那么请你返回 `True` ，否则返回 `False` 。一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png "Magic Gardens")
```
输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：true
解释：树中蓝色的节点构成了与链表对应的子路径。
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png "Magic Gardens")
```
输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：true
```

#### 示例 3：
```
输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
输出：false
解释：二叉树中不存在一一对应链表的路径。
```

#### 提示
- 二叉树和链表中的每个节点的值都满足 1 <= node.val <= 100 。
- 链表包含的节点数目在 1 到 100 之间。
- 二叉树包含的节点数目在 1 到 2500 之间。

```js
```

## 自底向上整合子树结果
### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree)
给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 3
```

#### 示例 2：
```
输入：root = [1,null,2]
输出: 2
```

#### 示例 3：
```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

#### 提示
- $树中节点的数量在 [0, 10^4] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root){
        return 0
    }
    const left = maxDepth(root.left)
    const right = maxDepth(root.right)

    return Math.max(left, right) + 1
};
```

### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree)
给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：** 叶子节点是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 2
```

#### 示例 2：
```
输入：root = [2,null,3,null,4,null,5,null,6]
输出: 5
```

#### 提示
- $树中节点的数量在 [0, 10^5] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root){
        return 0
    }
    const left = minDepth(root.left)
    const right = minDepth(root.right)

    if(!root.left){
        return right + 1
    }

    if(!root.right){
        return left + 1
    }

    return Math.min(left, right) + 1
};
```

### [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree)
给你二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg "Magic Gardens")
```
输入: root = [4,2,7,1,3,6,9]
输出: [4,7,2,9,6,3,1]
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg "Magic Gardens")
```
输入：root = [2,1,3]
输出: [2,3,1]
解释：树中存在两条根节点到叶子节点的路径：
```

#### 示例 3：
```
输入：root = []
输出：[]
```

#### 提示
- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root){
        return root
    }
    const left = invertTree(root.right)
    const right = invertTree(root.left)

    return new TreeNode(root.val, left, right)
};
```

### [路径总和](https://leetcode.cn/problems/path-sum)
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。**叶子节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg "Magic Gardens")
```
输入: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出: true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg "Magic Gardens")
```
输入：root = [1,2,3], targetSum = 5
输出: false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

#### 示例 3：
```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

#### 提示
- 树中节点的数目在范围 [0, 5000] 内
- -1000 <= Node.val <= 1000
- -1000 <= targetSum <= 1000

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root){
        return false
    }
    const diffVal = targetSum - root.val
    if(!root.left && !root.right){
        return diffVal === 0
    }

    return hasPathSum(root.left, diffVal) || hasPathSum(root.right, diffVal)
};
```

### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
给你一棵二叉树的根节点，返回该树的 **直径** 。二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。两节点之间路径的 **长度** 由它们之间边数表示。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg "Magic Gardens")
```
输入: root = [1,2,3,4,5]
输出: 3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

#### 示例 2：
```
输入：root = [1,2]
输出：1
```

#### 提示
- 树中节点数目在范围 $[1, 10^4]$ 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    let res = 0;
    const getDepth = node => {
        if(!node){
            return 0
        }

        const leftDepth = getDepth(node.left)
        const rightDepth = getDepth(node.right)

        res = Math.max(res, (leftDepth + rightDepth))

        return Math.max(leftDepth, rightDepth) + 1
    }

    getDepth(root)

    return res
};
```

### [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg "Magic Gardens")
```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg "Magic Gardens")
```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

#### 提示
- 树中节点数目范围是 [1, 3 * $10^4$]
- -1000 <= Node.val <= 1000

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
    let res = -Infinity;
    const dfs = node => {
        if(!node){
            return 0
        }
        const left = dfs(node.left)
        const right = dfs(node.right)
        const curSum = left + node.val + right;
        res = Math.max(res, curSum)
        const returnedSum = node.val + Math.max(0, left, right)

        return Math.max(0, returnedSum)
    }

    dfs(root)

    return res
};
```

### [在二叉树中分配硬币](https://leetcode.cn/problems/distribute-coins-in-binary-tree/)
给你一个有 `n` 个结点的二叉树的根结点 `root` ，其中树中每个结点 `node` 都对应有 `node.val` 枚硬币。整棵树上一共有 `n` 枚硬币。在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。返回使每个结点上 **只有** 一枚硬币所需的 **最少** 移动次数。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2019/01/18/tree1.png "Magic Gardens")
```
输入：root = [3,0,0]
输出：2
解释：一枚硬币从根结点移动到左子结点，一枚硬币从根结点移动到右子结点。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2019/01/18/tree2.png "Magic Gardens")
```
输入：root = [0,3,0]
输出：3
解释：将两枚硬币从根结点的左子结点移动到根结点（两次移动）。然后，将一枚硬币从根结点移动到右子结点。
```

#### 提示
- 树中节点的数目为 n
- 1 <= n <= 100
- 0 <= Node.val <= n
- 所有 Node.val 的值之和是 n

```js
```

### [出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)
给你一个二叉树的根结点 `root` ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。一个结点的 `「子树元素和」` 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg "Magic Gardens")
```
输入: root = [5,2,-3]
输出: [2,-3,4]
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg "Magic Gardens")
```
输入: root = [5,2,-5]
输出: [2]
```

#### 提示
- 节点数在 [1, 104] 范围内
- $-10^5 <= Node.val <= 10^5$

```js
```

### [二叉树的坡度](https://leetcode.cn/problems/binary-tree-tilt/)
给你一个二叉树的根节点 `root` ，计算并返回 **整个树** 的坡度 。一个树的 **节点的坡度** 定义即为，该节点左子树的节点之和和右子树节点之和的 **差的绝对值** 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。**整个树** 的坡度就是其所有节点的坡度之和。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg "Magic Gardens")
```
输入：root = [1,2,3]
输出：1
解释：
节点 2 的坡度：|0-0| = 0（没有子节点）
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
坡度总和：0 + 0 + 1 = 1
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg "Magic Gardens")
```
输入：root = [4,2,9,3,5,null,7]
输出：15
解释：
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 5 的坡度：|0-0| = 0（没有子节点）
节点 7 的坡度：|0-0| = 0（没有子节点）
节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）
节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）
节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）
坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg "Magic Gardens")
```
输入：root = [21,7,14,1,1,2,2,3,3]
输出：9
```

#### 提示
- 树中节点数目的范围在 [0, $10^4$] 内
- -1000 <= Node.val <= 1000

```js
```

### [删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/)
给你一棵以 `root` 为根的二叉树和一个整数 `target` ，请你删除所有值为 `target` 的 **叶子节点** 。注意，一旦删除值为 `target` 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 `target` ，那么这个节点也应该被删除。也就是说，你需要重复此过程直到不能继续删除。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png "Magic Gardens")
```
输入：root = [1,2,3,2,null,2,4], target = 2
输出：[1,null,3,null,4]
解释：
上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。
有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_2_1684.png "Magic Gardens")
```
输入：root = [1,3,3,3,2], target = 3
输出：[1,3,null,null,2]
```

#### 示例 3：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_3_1684.png "Magic Gardens")
```
输入：root = [1,2,null,2,null,2], target = 2
输出：[1]
解释：每一步都删除一个绿色的叶子节点（值为 2）。
```

#### 示例 4：
```
输入：root = [1,1,1], target = 1
输出：[]
```

#### 示例 5：
```
输入：root = [1,2,3], target = 1
输出：[1,2,3]
```

#### 提示
- 1 <= target <= 1000
- 每一棵树最多有 3000 个节点。
- 每一个节点值的范围是 [1, 1000]。

```js
```

### [寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)
给你一棵二叉树的根节点 `root` ，返回所有 **重复的子树** 。对于同一类的重复子树，你只需要返回其中任意 **一棵** 的根结点即可。如果两棵树具有 **相同的结构** 和 **相同的结点值** ，则认为二者是 **重复** 的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg "Magic Gardens")
```
输入：root = [1,2,3,4,null,2,4,null,null,4]
输出：[[2,4],[4]]
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg "Magic Gardens")
```
输入：root = [2,1,1]
输出：[[1]]
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg "Magic Gardens")
```
输入：root = [2,2,2,3,null,3,null]
输出：[[2,3],[3]]
```

#### 提示
- 树中的结点数在 [1, 5000] 范围内。
- -200 <= Node.val <= 200

```js
```

### [二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)
给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：
- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。请你返回给定树中最长 **交错路径** 的长度。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png "Magic Gardens")
```
输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png "Magic Gardens")
```
输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
```

#### 示例 3：
```
输入：root = [1]
输出：0
```

#### 提示
- 每棵树最多有 50000 个节点。
- 每个节点的值在 [1, 100] 之间。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestZigZag = function (root) {
    let res = 0
    const dfs = (node, l, r) => {
        if (!node) {
            return
        }
        res = Math.max(res, l, r)
        dfs(node.left, r + 1, 0)
        dfs(node.right, 0, l + 1)
    }
    dfs(root, 0, 0)

    return res
};
```

## 层序遍历及变种
### [二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg "Magic Gardens")
```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

#### 示例 2：
```
输入：root = [1]
输出：[[1]]
```

#### 示例 3：
```
输入：root = []
输出：[]
```

#### 提示
- 树中节点数目在范围 [0, 2000] 内
- -1000 <= Node.val <= 1000

```js
```

### [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)
给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg "Magic Gardens")
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

#### 示例 2：
```
输入：root = [1]
输出：[[1]]
```

#### 示例 3：
```
输入：root = []
输出：[]
```

#### 提示
- 树中节点数目在范围 [0, 2000] 内
- -100 <= Node.val <= 100

```js
```

### [二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 $10^-5$ 以内的答案可以被接受。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg "Magic Gardens")
```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg "Magic Gardens")
```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```

#### 提示
- 树中节点数量在 $[1, 10^4]$ 范围内
- $-2^31 <= Node.val <= 2^31 - 1$

```js
```

### [二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)
在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png "Magic Gardens")
```
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png "Magic Gardens")
```
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
```

#### 示例 3：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png "Magic Gardens")
```
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
```

#### 提示
- 二叉树的节点数介于 2 到 100 之间。
- 每个节点的值都是唯一的、范围为 1 到 100 的整数。

```js
```

### [二叉树的垂序遍历](https://leetcode.cn/problems/binary-tree-vertical-order-traversal/)
给你一个二叉树的根结点，返回其结点按 **垂直方向**（从上到下，逐列）遍历的结果。如果两个结点在同一行和列，那么顺序则为 **从左到右**。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg "Magic Gardens")
```
输入：root = [3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg "Magic Gardens")
```
输入：root = [3,9,8,4,0,1,7]
输出：[[4],[9],[3,0,1],[8],[7]]
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg "Magic Gardens")
```
输入：root = [3,9,8,4,0,1,7,null,null,null,2,5]
输出：[[4],[9,5],[3,0,1],[8,2],[7]]
```

#### 提示
- 树中结点的数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

```js
```

## DFS或BFS均可解决的问题
### [找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)
给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层** **最左边** 节点的值。假设二叉树中至少有一个节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg "Magic Gardens")
```
输入: root = [2,1,3]
输出: 1
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg "Magic Gardens")
```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

#### 提示
- 二叉树的节点个数的范围是 $[1,10^4]$
- $-2^31 <= Node.val <= 2^31 - 1$

```js
```

### [在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg "Magic Gardens")
```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
```

#### 示例 2：
```
输入: root = [1,2,3]
输出: [1,3]
```

#### 提示
- 二叉树的节点个数的范围是 $[0,10^4]$
- $-2^31 <= Node.val <= 2^31 - 1$

```js
```

### [在二叉树中增加一行](https://leetcode.cn/problems/add-one-row-to-tree/)
给定一个二叉树的根 `root` 和两个整数 `val` 和 `depth` ，在给定的深度 `depth` 处添加一个值为 `val` 的节点行。注意，根节点 root 位于深度 1 。加法规则如下:
- 给定整数 `depth`，对于深度为 `depth - 1` 的每个非空树节点 `cur` ，创建两个值为 `val` 的树节点作为 `cur` 的左子树根和右子树根。
- `cur` 原来的左子树应该是新的左子树根的左子树。
- `cur` 原来的右子树应该是新的右子树根的右子树。
- 如果 `depth == 1` 意味着 `depth - 1` 根本没有深度，那么创建一个树节点，值 `val` 作为整个原始树的新根，而原始树就是新根的左子树。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg "Magic Gardens")
```
输入: root = [4,2,6,3,1,5], val = 1, depth = 2
输出: [4,1,1,2,null,null,6,3,1,5]
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg "Magic Gardens")
```
输入: root = [4,2,null,3,1], val = 1, depth = 3
输出:  [4,2,null,1,1,3,null,null,1]
```

#### 提示
- 节点数在 $[1, 10^4]$ 范围内
- 树的深度在 $[1, 10^4]$范围内
- -100 <= Node.val <= 100
- $-10^5 <= val <= 10^5$
- 1 <= depth <= the depth of tree + 1

```js
```

## 只能用DFS解决的问题
### [求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
计算从根节点到叶节点生成的 **所有数字之和** 。**叶节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg "Magic Gardens")
```
输入: root = [1,2,3]
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg "Magic Gardens")
```
输入：root = [4,9,0,5,1]
输出: 1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

#### 提示
- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    let res = 0;
    const dfs = (node, sum) => {
        if(!node){
            return
        }
        sum = sum * 10 + node.val
        if(!node.left && !node.right){
            res += sum

            return 
        }
        dfs(node.left, sum)
        dfs(node.right, sum)
    }
    dfs(root, 0)

    return res
};
```

### [二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
给你一棵指定的二叉树的根节点 `root` ，请你计算其中 **最长连续序列路径** 的长度。**最长连续序列路径** 是依次递增 1 的路径。该路径，可以是从某个初始节点到树中任意节点，通过「父 - 子」关系连接而产生的任意路径。且必须从父节点到子节点，反过来是不可以的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg "Magic Gardens")
```
输入：root = [1,null,3,2,4,null,null,null,5]
输出：3
解释：当中，最长连续序列是 3-4-5 ，所以返回结果为 3 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg "Magic Gardens")
```
输入：root = [2,null,3,2,null,1]
输出：2
解释：当中，最长连续序列是 2-3 。注意，不是 3-2-1，所以返回 2 。
```

#### 提示
- $树中节点的数目在范围 [1, 3 * 10^4] 内$
- $-3 * 10^4 <= Node.val <= 3 * 10^4$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestConsecutive = function (root) {
    let res = 0;
    const dfs = (curNode, parentNode, len) => {
        if (!curNode) {
            return
        }
        len = (parentNode && curNode.val === parentNode.val + 1) ? len + 1 : 1;
        res = Math.max(res, len)
        dfs(curNode.left, curNode, len)
        dfs(curNode.right, curNode, len)
    }

    return res
};
```

### [最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)
给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。**两个节点之间的路径长度** 由它们之间的边数表示。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg "Magic Gardens")
```
输入：root = [5,4,5,1,1,5]
输出：2
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg "Magic Gardens")
```
输入：root = [1,4,5,4,4,5]
输出：2
```

#### 提示
- 树的节点数的范围是 $[0, 10^4]$ 
- -1000 <= Node.val <= 1000
- 树的深度将不超过 1000 

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function (root) {
    let res = 0;
    const dfs = node => {
        if (!node) {
            return 0
        }
        const left = dfs(node.left)
        const right = dfs(node.right)
        let leftPath = 0;
        let rightPath = 0;
        if (node.left && node.left.val === node.val) {
            leftPath = left + 1
        }
        if (node.right && node.right.val === node.val) {
            rightPath = right + 1
        }
        res = Math.max(res, leftPath + rightPath)

        return Math.max(rightPath, leftPath)
    }

    dfs(root)

    return res
};
```

### [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg "Magic Gardens")
```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

#### 示例 2：
```
输入: [1,null,3]
输出: [1,3]
```

#### 示例 3：
```
输入: []
输出: []
```

#### 提示
- 二叉树的节点个数的范围是 [0,100]
- -100 <= Node.val <= 100 

```js
```

## 需要两次搜索才能解决的问题
### [输出二叉树](https://leetcode.cn/problems/print-binary-tree/)
给你一棵二叉树的根节点 `root` ，请你构造一个下标从 **0** 开始、大小为 `m x n` 的字符串矩阵 `res` ，用以表示树的 **格式化布局** 。构造此格式化布局矩阵需要遵循以下规则：
- 树的 **高度** 为 `height` ，矩阵的行数 `m` 应该等于 `height + 1` 。
- 矩阵的列数 `n` 应该等于 2^height+1 - 1 。
- **根节点** 需要放置在 **顶行** 的 **正中间** ，对应位置为 res[0][(n-1)/2] 。
- 对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1] 。
- 继续这一过程，直到树中的所有节点都妥善放置。
- 任意空单元格都应该包含空字符串 `""` 。

返回构造得到的矩阵 `res` 。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg "Magic Gardens")
```
输入：root = [1,2]
输出：
[["","1",""],
 ["2","",""]]
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg "Magic Gardens")
```
输入：root = [1,2,3,null,4]
输出：
[["","","","1","","",""],
 ["","2","","","","3",""],
 ["","","4","","","",""]]
```

#### 提示
- 树中节点数在范围 $[1, 2^10]$ 内
- -99 <= Node.val <= 99
- 树的深度在范围 [1, 10] 内

```js
```

### [分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/)
给你一棵二叉树，它的根为 `root` 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_1_1699.png "Magic Gardens")
```
输入：root = [1,2,3,4,5,6]
输出：110
解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/02/sample_2_1699.png "Magic Gardens")
```
输入：root = [1,null,2,3,4,null,null,5,6]
输出：90
解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6）
```

#### 示例 3：
```
输入：root = [2,3,9,10,7,8,6,5,4,11,1]
输出：1025
```

#### 示例 4：
```
输入：root = [1,1]
输出：1
```

#### 提示
- 每棵树最多有 50000 个节点，且至少有 2 个节点。
- 每个节点的值在 [1, 10000] 之间。

```js
```

### [二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)
给定一个二叉树（具有根结点 `root`）， 一个目标结点 `target` ，和一个整数值 `k` 。返回到目标结点 `target` 距离为 `k` 的所有结点的值的列表。 答案可以以 **任何顺序** 返回。

#### 示例 1：
![这是图片](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
输出：[7,4,1]
解释：所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
```

#### 示例 2：
```
输入: root = [1], target = 1, k = 3
输出: []
```

#### 提示
- 节点数在 [1, 500] 范围内
- 0 <= Node.val <= 500
- Node.val 中所有值 不同
- 目标结点 target 是树上的结点。
- 0 <= k <= 1000

```js
```

## 最近公共祖先问题
### [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大 **（一个节点也可以是它自己的祖先）** 。”

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 树中节点数目在范围 $[2, 10^5]$ 内。
- $-10^9 <= Node.val <= 10^9$
- 所有 `Node.val` 互不相同。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(!root){
        return root
    }
    if(root === p || root === q){
        return root
    }
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if(left && right){
        return root
    }

    return left ? left : right
};
```

#### 相关题目
[二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

### [具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/)
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。返回包含原始树中所有 **最深节点** 的 *最小子树* 。如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。一个节点的 **子树** 是该节点加上它的所有后代的集合。

#### 示例 1：
![这是图片](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。
```

#### 示例 2：
```
输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
```

#### 示例 3：
```
输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
```

#### 提示
- 树中节点的数量在 [1, 500] 范围内。
- 0 <= Node.val <= 500
- 每个节点的值都是 **独一无二** 的。 

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var subtreeWithAllDeepest = function (root) {
    const dfs = node => {
        if (!node) {
            return [0, node]
        }
        const [leftDepth, leftNode] = dfs(node.left)
        const [rightDepth, rightNode] = dfs(node.right)
        if (leftDepth > rightDepth) {
            return [leftDepth + 1, leftNode]
        }
        if (leftDepth < rightDepth) {
            return [rightDepth + 1, rightNode]
        }
        return [leftDepth + 1, node]
    }

    return dfs(root)[1]
};
```