## 目录

- [树](#树)
  - [树的遍历](#树的遍历)
  - [二叉树的最大深度](#二叉树的最大深度)
  - [二叉树的最小深度](#二叉树的最小深度)
  - [路径总和](#路径总和)
  - [翻转二叉树](#翻转二叉树)
  - [相同的树](#相同的树)
  - [对称二叉树](#对称二叉树)
  - [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
  - [二叉树的最近公共祖先](#二叉树的最近公共祖先)
  - [从前序与中序遍历序列构造二叉树](#从前序与中序遍历序列构造二叉树)
  - [前序遍历构造二叉搜索树](#前序遍历构造二叉搜索树)
  - [二叉树的直径](#二叉树的直径)
  - [二叉树中的最大路径和](#二叉树中的最大路径和)
  - [二叉树最长连续序列](#二叉树最长连续序列)
  - [最长同值路径](#最长同值路径)
  - [具有所有最深节点的最小子树](#具有所有最深节点的最小子树)
  - [二叉树中的最长交错路径](#二叉树中的最长交错路径)

## 树
### 树的遍历
使用栈模拟的二叉树深度优先遍历的过程，下面实现了二叉树的前序遍历，改变stack的压栈顺序即可实现中序遍历、后序遍历，以及N叉树的前序遍历、后序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
    if (!root) {
        return []
    }
    const ret = []
    const stack = [new Command('GO', root)]
    while (stack.length) {
        const curCommand = stack.pop()
        if (curCommand.action === 'ADD') {
            ret.push(curCommand.node.val)
        } else {
            if (curCommand.node.right != null) {
                stack.push(new Command('GO', curCommand.node.right));
            }
            if (curCommand.node.left != null) {
                stack.push(new Command('GO', curCommand.node.left));
            }
            stack.push(new Command('ADD', curCommand.node));
        }
    }

    return ret
};

function Command(action, node) {
    this.action = action;
    this.node = node
}
```

#### 相关题目
[二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal)

[二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal)

[二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

[N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal)

[N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal)

### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree)
给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 3
```

#### 示例 2：
```
输入：root = [1,null,2]
输出: 2
```

#### 示例 3：
```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

#### 提示
- $树中节点的数量在 [0, 10^4] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root){
        return 0
    }
    const left = maxDepth(root.left)
    const right = maxDepth(root.right)

    return Math.max(left, right) + 1
};
```

### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree)
给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：** 叶子节点是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg "Magic Gardens")
```
输入: root = [3,9,20,null,null,15,7]
输出: 2
```

#### 示例 2：
```
输入：root = [2,null,3,null,4,null,5,null,6]
输出: 5
```

#### 提示
- $树中节点的数量在 [0, 10^5] 区间内。$
- $-100 <= Node.val <= 100$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root){
        return 0
    }
    const left = minDepth(root.left)
    const right = minDepth(root.right)

    if(!root.left){
        return right + 1
    }

    if(!root.right){
        return left + 1
    }

    return Math.min(left, right) + 1
};
```

### [路径总和](https://leetcode.cn/problems/path-sum)
给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。**叶子节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg "Magic Gardens")
```
输入: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出: true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg "Magic Gardens")
```
输入：root = [1,2,3], targetSum = 5
输出: false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

#### 示例 3：
```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

#### 提示
- 树中节点的数目在范围 [0, 5000] 内
- -1000 <= Node.val <= 1000
- -1000 <= targetSum <= 1000

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root){
        return false
    }
    const diffVal = targetSum - root.val
    if(!root.left && !root.right){
        return diffVal === 0
    }

    return hasPathSum(root.left, diffVal) || hasPathSum(root.right, diffVal)
};
```

### [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree)
给你二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg "Magic Gardens")
```
输入: root = [4,2,7,1,3,6,9]
输出: [4,7,2,9,6,3,1]
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg "Magic Gardens")
```
输入：root = [2,1,3]
输出: [2,3,1]
解释：树中存在两条根节点到叶子节点的路径：
```

#### 示例 3：
```
输入：root = []
输出：[]
```

#### 提示
- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root){
        return root
    }
    const left = invertTree(root.right)
    const right = invertTree(root.left)

    return new TreeNode(root.val, left, right)
};
```

### [相同的树](https://leetcode.cn/problems/same-tree/)
给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg "Magic Gardens")
```
输入: p = [1,2,3], q = [1,2,3]
输出: true
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 提示
- 两棵树上的节点数目都在范围 `[0, 100]` 内
- $-10^4 <= Node.val <= 10^4$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (p, q) {
    if (!p && !q) {
        return true
    }

    if(p && q && p.val === q.val){
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }

    return false
};
```

### [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

#### 示例 1：
![这是图片](https://pic.leetcode.cn/1698026966-JDYPDU-image.png "Magic Gardens")
```
输入: root = [1,2,2,3,4,4,3]
输出: true
```

#### 示例 2：
![这是图片](https://pic.leetcode.cn/1698027008-nPFLbM-image.png "Magic Gardens")
```
输入：p = [1,2], q = [1,null,2]
输出: false
```

#### 示例 3：
![这是图片](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg "Magic Gardens")
```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

#### 提示
- 树中节点数目在范围 `[1, 1000]` 内
- -100 <= Node.val <= 100

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if(!root){
        return true
    }

    return isSymmetricCore(root.left, root.right)
};

function isSymmetricCore(node1, node2) {
    if (!node1 && !node2) {
        return true
    }

    if (node1 && node2 && node1.val === node2.val) {
        return isSymmetricCore(node1.left, node2.right) && isSymmetricCore(node1.right, node2.left)
    }

    return false
}
```

### [求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
计算从根节点到叶节点生成的 **所有数字之和** 。**叶节点** 是指没有子节点的节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg "Magic Gardens")
```
输入: root = [1,2,3]
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg "Magic Gardens")
```
输入：root = [4,9,0,5,1]
输出: 1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

#### 提示
- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumNumbers = function(root) {
    let res = 0;
    const dfs = (node, sum) => {
        if(!node){
            return
        }
        sum = sum * 10 + node.val
        if(!node.left && !node.right){
            res += sum

            return 
        }
        dfs(node.left, sum)
        dfs(node.right, sum)
    }
    dfs(root, 0)

    return res
};
```

### [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大 **（一个节点也可以是它自己的祖先）** 。”

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 树中节点数目在范围 $[2, 10^5]$ 内。
- $-10^9 <= Node.val <= 10^9$
- 所有 `Node.val` 互不相同。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if(!root){
        return root
    }
    if(root === p || root === q){
        return root
    }
    const left = lowestCommonAncestor(root.left, p, q)
    const right = lowestCommonAncestor(root.right, p, q)
    if(left && right){
        return root
    }

    return left ? left : right
};
```

### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg "Magic Gardens")
```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

#### 示例 2：
```
输入：preorder = [-1], inorder = [-1]
输出: [-1]
```

#### 示例 3：
```
输入：root = [1,2], p = 1, q = 2
输出: 1
```

#### 提示
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- preorder 和 inorder 均 无重复 元素
- inorder 均出现在 preorder
- preorder 保证 为二叉树的前序遍历序列
- inorder 保证 为二叉树的中序遍历序列

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if(!preorder.length || !inorder.length){
        return null
    }
    const rootVal = preorder.shift()
    const index = inorder.findIndex(number => number === rootVal)
    const leftPreorder = preorder.slice(0, index)
    const rightPreorder = preorder.slice(index)
    const leftInorder = inorder.slice(0, index)
    const rightInorder = inorder.slice(index + 1)
    const left = buildTree(leftPreorder, leftInorder)
    const right = buildTree(rightPreorder, rightInorder)

    return new TreeNode(rootVal, left, right)
};
```

#### 相关题目
[从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### [前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)
给定一个整数数组，它表示BST(即 **二叉搜索树** )的 **先序遍历** ，构造树并返回其根。**保证** 对于给定的测试用例，总是有可能找到具有给定需求的二叉搜索树。**二叉搜索树** 是一棵二叉树，其中每个节点，`Node.left` 的任何后代的值 **严格小于** `Node.val` , `Node.right` 的任何后代的值 **严格大于** `Node.val`。二叉树的 **前序遍历** 首先显示节点的值，然后遍历`Node.left`，最后遍历`Node.right`。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2019/03/06/1266.png "Magic Gardens")
```
输入: preorder = [8,5,1,7,10,12]
输出: [8,5,10,1,7,null,12]
```

#### 示例 2：
```
输入：preorder = [1,3]
输出: [1,null,3]
```

#### 提示
- 1 <= preorder.length <= 100
- 1 <= preorder[i] <= 10^8
- preorder 中的值 **互不相同**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function (preorder) {
    const tree = new Tree()
    preorder.forEach(num => tree.insert(num))

    return tree.root
};

function Tree() {
    this.root = null;

    this.insert = function (val) {
        const newNode = new TreeNode(val)

        if (!this.root) {
            this.root = newNode
        } else {
            insertNode(this.root, newNode);
        }
    }

    function insertNode(node, newNode) {
        if (newNode.val < node.val) {
            if (!node.left) {
                node.left = newNode
            } else {
                insertNode(node.left, newNode)
            }
        } else {
            if (!node.right) {
                node.right = newNode
            } else {
                insertNode(node.right, newNode)
            }
        }
    }
}
```

### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
给你一棵二叉树的根节点，返回该树的 **直径** 。二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。两节点之间路径的 **长度** 由它们之间边数表示。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg "Magic Gardens")
```
输入: root = [1,2,3,4,5]
输出: 3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

#### 示例 2：
```
输入：root = [1,2]
输出：1
```

#### 提示
- 树中节点数目在范围 $[1, 10^4]$ 内
- `-100 <= Node.val <= 100`

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    let res = 0;
    const getDepth = node => {
        if(!node){
            return 0
        }

        const leftDepth = getDepth(node.left)
        const rightDepth = getDepth(node.right)

        res = Math.max(res, (leftDepth + rightDepth))

        return Math.max(leftDepth, rightDepth) + 1
    }

    getDepth(root)

    return res
};
```

### [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg "Magic Gardens")
```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg "Magic Gardens")
```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

#### 提示
- 树中节点数目范围是 [1, 3 * $10^4$]
- -1000 <= Node.val <= 1000

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxPathSum = function(root) {
    let res = -Infinity;
    const dfs = node => {
        if(!node){
            return 0
        }
        const left = dfs(node.left)
        const right = dfs(node.right)
        const curSum = left + node.val + right;
        res = Math.max(res, curSum)
        const returnedSum = node.val + Math.max(0, left, right)

        return Math.max(0, returnedSum)
    }

    dfs(root)

    return res
};
```

### [二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)
给你一棵指定的二叉树的根节点 `root` ，请你计算其中 **最长连续序列路径** 的长度。**最长连续序列路径** 是依次递增 1 的路径。该路径，可以是从某个初始节点到树中任意节点，通过「父 - 子」关系连接而产生的任意路径。且必须从父节点到子节点，反过来是不可以的。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/consec1-1-tree.jpg "Magic Gardens")
```
输入：root = [1,null,3,2,4,null,null,null,5]
输出：3
解释：当中，最长连续序列是 3-4-5 ，所以返回结果为 3 。
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2021/03/14/consec1-2-tree.jpg "Magic Gardens")
```
输入：root = [2,null,3,2,null,1]
输出：2
解释：当中，最长连续序列是 2-3 。注意，不是 3-2-1，所以返回 2 。
```

#### 提示
- $树中节点的数目在范围 [1, 3 * 10^4] 内$
- $-3 * 10^4 <= Node.val <= 3 * 10^4$

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestConsecutive = function (root) {
    let res = 0;
    const dfs = (curNode, parentNode, len) => {
        if (!curNode) {
            return
        }
        len = (parentNode && curNode.val === parentNode.val + 1) ? len + 1 : 1;
        res = Math.max(res, len)
        dfs(curNode.left, curNode, len)
        dfs(curNode.right, curNode, len)
    }

    return res
};
```

### [最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)
给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。**两个节点之间的路径长度** 由它们之间的边数表示。

#### 示例 1：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg "Magic Gardens")
```
输入：root = [5,4,5,1,1,5]
输出：2
```

#### 示例 2：
![这是图片](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg "Magic Gardens")
```
输入：root = [1,4,5,4,4,5]
输出：2
```

#### 提示
- 树的节点数的范围是 $[0, 10^4]$ 
- -1000 <= Node.val <= 1000
- 树的深度将不超过 1000 

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function (root) {
    let res = 0;
    const dfs = node => {
        if (!node) {
            return 0
        }
        const left = dfs(node.left)
        const right = dfs(node.right)
        let leftPath = 0;
        let rightPath = 0;
        if (node.left && node.left.val === node.val) {
            leftPath = left + 1
        }
        if (node.right && node.right.val === node.val) {
            rightPath = right + 1
        }
        res = Math.max(res, leftPath + rightPath)

        return Math.max(rightPath, leftPath)
    }

    dfs(root)

    return res
};
```

### [具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/)
给定一个根为 `root` 的二叉树，每个节点的深度是 **该节点到根的最短距离** 。返回包含原始树中所有 **最深节点** 的 *最小子树* 。如果一个节点在 **整个树** 的任意节点之间具有最大的深度，则该节点是 **最深的** 。一个节点的 **子树** 是该节点加上它的所有后代的集合。

#### 示例 1：
![这是图片](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png "Magic Gardens")
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。
```

#### 示例 2：
```
输入：root = [1]
输出：[1]
解释：根节点是树中最深的节点。
```

#### 示例 3：
```
输入：root = [0,1,3,null,2]
输出：[2]
解释：树中最深的节点为 2 ，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。
```

#### 提示
- 树中节点的数量在 [1, 500] 范围内。
- 0 <= Node.val <= 500
- 每个节点的值都是 **独一无二** 的。 

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var subtreeWithAllDeepest = function (root) {
    const dfs = node => {
        if (!node) {
            return [0, node]
        }
        const [leftDepth, leftNode] = dfs(node.left)
        const [rightDepth, rightNode] = dfs(node.right)
        if (leftDepth > rightDepth) {
            return [leftDepth + 1, leftNode]
        }
        if (leftDepth < rightDepth) {
            return [rightDepth + 1, rightNode]
        }
        return [leftDepth + 1, node]
    }

    return dfs(root)[1]
};
```

### [二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)
给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。请你返回给定树中最长 **交错路径** 的长度。

#### 示例 1：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_1_1702.png "Magic Gardens")
```
输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
```

#### 示例 2：
![这是图片](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/07/sample_2_1702.png "Magic Gardens")
```
输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
```

#### 示例 3：
```
输入：root = [1]
输出：0
```

#### 提示
- 每棵树最多有 50000 个节点。
- 每个节点的值在 [1, 100] 之间。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestZigZag = function (root) {
    let res = 0
    const dfs = (node, l, r) => {
        if (!node) {
            return
        }
        res = Math.max(res, l, r)
        dfs(node.left, r + 1, 0)
        dfs(node.right, 0, l + 1)
    }
    dfs(root, 0, 0)

    return res
};
```