## 目录

- [数组中递归](#数组中递归)
  - [数组中的第 K 个最大元素](#数组中的第-k-个最大元素)
  - [计算右侧小于当前元素的个数](#计算右侧小于当前元素的个数)
  - [翻转对](#翻转对)
  - [正则表达式匹配](#正则表达式匹配)

## 数组中递归
### [数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

#### 示例 1：
```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

#### 示例 2：
```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

#### 提示
- $1 <= k <= nums.length <= 10^5$
- $-10^4 <= nums[i] <= 10^4$

```js
```

### [计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)
给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

#### 示例 1：
```
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```

#### 示例 2：
```
输入：nums = [-1]
输出：[0]
```

#### 示例 3：
```
输入：nums = [-1,-1]
输出：[0,0]
```

#### 提示
- $1 <= nums.length <= 10^5$
- $-10^4 <= nums[i] <= 10^4$

```js
```

### [翻转对](https://leetcode.cn/problems/reverse-pairs/)
给定一个数组 `nums` ，如果 `i < j` 且 `nums[i] > 2*nums[j]` 我们就将 `(i, j)` 称作一个 ***重要翻转对*** 。你需要返回给定数组中的重要翻转对的数量。

#### 示例 1：
```
输入: [1,3,2,3,1]
输出: 2
```

#### 示例 2：
```
输入: [2,4,3,5,1]
输出: 3
```

#### 提示
1. 给定数组的长度不会超过50000。
2. 输入数组中的所有数字都在32位整数的表示范围内。

```js
```

### [正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)
给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。
- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

#### 示例 1：
```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

#### 示例 2：
```
输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

#### 示例 3：
```
输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

#### 提示
- 1 <= s.length <= 20
- 1 <= p.length <= 20
- s 只包含从 a-z 的小写字母。
- p 只包含从 a-z 的小写字母，以及字符 . 和 *。
- 保证每次出现字符 * 时，前面都匹配到有效的字符

```js
```